package futures

import (
	"context"
	"fmt"
	"sort"
	"testing"
	"time"

	"github.com/bradfitz/iter"
)

// Delay unit, high enough that system slowness doesn't affect timing, but low
// enough to ensure tests are fast.
const u = 20 * time.Millisecond

func TestAsCompletedDelayed(t *testing.T) {
	t.Parallel()
	var fs []*F[struct{}]
	s := time.Now()
	for i := range iter.N(10) {
		f := timeoutFuture(time.Duration(i) * u)
		f.SetName(fmt.Sprintf("%d", i))
		fs = append(fs, f)
	}
	as := AsCompletedDelayed(
		context.Background(),
		[]*F[struct{}]{fs[0], fs[2]},
		[]Delayed[struct{}]{
			{u, []*F[struct{}]{fs[1]}},
			{3 * u, []*F[struct{}]{fs[0]}},
		},
	)
	a := func(f, when time.Duration) {
		t.Helper()
		next := <-as
		if next != fs[f] {
			t.FailNow()
		}
		//assert.Equal(t, fs[f], <-as)
		if time.Since(s) < when*u {
			t.Errorf("%d completed too soon", f)
		}
		if time.Since(s) >= (when+1)*u {
			t.Errorf("%d completed too late", f)
		}
	}
	a(0, 0)
	a(1, 1)
	a(2, 2)
	a(0, 2)
	_, ok := <-as
	if ok {
		t.FailNow()
	}
	if time.Since(s) >= 4*u {
		t.Fatal("took too long")
	}
	//assert.False(t, ok)
	//assert.True(t, time.Since(s) < 4*u)
}

func TestAsCompletedDelayedContextCanceled(t *testing.T) {
	t.Parallel()
	var fs []*F[struct{}]
	s := time.Now()
	for i := range iter.N(10) {
		f := timeoutFuture(time.Duration(i) * u)
		f.SetName(fmt.Sprintf("%d", i))
		fs = append(fs, f)
	}
	ctx, cancel := context.WithCancel(context.Background())
	as := AsCompletedDelayed(
		ctx,
		[]*F[struct{}]{fs[0], fs[2]},
		[]Delayed[struct{}]{
			{u, []*F[struct{}]{fs[1]}},
			{3 * u, []*F[struct{}]{fs[0]}},
		},
	)
	a := func(f, when time.Duration) {
		t.Helper()
		next := <-as
		if next != fs[f] {
			t.Fatal("got wrong future")
		}
		//assert.Equal(t, fs[f], <-as)
		if time.Since(s) < when*u {
			t.Errorf("%d completed too soon", f)
		}
		if time.Since(s) >= (when+1)*u {
			t.Errorf("%d completed too late", f)
		}
	}
	a(0, 0)
	cancel()
	_, ok := <-as
	if ok {
		t.FailNow()
	}
	if time.Since(s) >= u {
		t.Fatal("took too long")
	}
	//assert.False(t, ok)
	//assert.True(t, time.Since(s) < 1*u)
}

func TestAsCompletedImmediate(t *testing.T) {
	t.Parallel()
	var fs []*F[struct{}]
	s := time.Now()
	for i := range iter.N(10) {
		f := timeoutFuture(0)
		f.SetName(fmt.Sprintf("%d", i))
		fs = append(fs, f)
	}
	as := AsCompletedDelayed(
		context.Background(),
		[]*F[struct{}]{fs[0], fs[2]},
	[]Delayed[struct{}]{
		{u, []*F[struct{}]{fs[1]}},
		{3 * u, []*F[struct{}]{fs[0]}},
	},
)
	a := func(when time.Duration, indices ...int) {
		t.Helper()
		var got []int
		for len(got) != len(indices) {
			next := <-as
			for i, f := range fs {
				if next==f {
					got = append(got, i)
				}
			}
		}
		sort.Ints(got)
		for i := range indices {
			if indices[i] != got[i] {
				t.Fatalf("expected future %v, got %v", indices[i], got[i])
			}
		}
		if time.Since(s) < when*u {
			t.Errorf("completed too soon")
		}
		if time.Since(s) >= (when+1)*u {
			t.Errorf("completed too late")
		}
	}
	a(0,0,2)
	a(0,1)
	a(0,0)
	_, ok := <-as
	if ok {
		t.FailNow()
	}
	if time.Since(s) >= 4*u {
		t.Fatal("took too long")
	}
	//assert.False(t, ok)
	//assert.True(t, time.Since(s) < 4*u)
}
