package futures

import (
	"fmt"
	"sync"
)

func Start[T](fn func() (T, error)) *F[T] {
	f := &F[T]{
		done: make(chan struct{}),
	}
	go func() {
		f.setResult(fn())
	}()
	return f
}

func StartNoError[T](fn func() T) *F[T] {
	return Start(func() (T, error) {
		return fn(), nil
	})
}

type F[T any] struct {
	name   string
	mu     sync.Mutex
	result T
	err    error
	done   chan struct{}
}

func (f *F[T]) String() string {
	if f.name != "" {
		return f.name
	}
	return fmt.Sprintf("future %p", f)
}

func (f *F[T]) SetName(s string) {
	f.name = s
}

func (f *F[T]) Err() error {
	<-f.done
	return f.err
}

// TODO: Just return value.
func (f *F[T]) Result() (T, error) {
	<-f.done
	f.mu.Lock()
	defer f.mu.Unlock()
	return f.result, f.err
}

func (f *F[T]) MustResult() T {
	val, err := f.Result()
	if err != nil {
		panic(err)
	}
	return val
}

func (f *F[T]) Done() <-chan struct{} {
	return f.done
}

func (f *F[T]) setResult(result T, err error) {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.result = result
	f.err = err
	close(f.done)
}

func (f *F[T]) ScanResult(res *T) (err error) {
	*res, err = f.Result()
	return
}
