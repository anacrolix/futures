// Code generated by go2go; DO NOT EDIT.


//line delayed_test.go2:1
package futures

//line delayed_test.go2:1
import (
//line delayed_test.go2:1
 "context"
//line delayed_test.go2:1
 "fmt"
//line delayed_test.go2:1
 "github.com/anacrolix/missinggo/slices"
//line delayed_test.go2:1
 "github.com/bradfitz/iter"
//line delayed_test.go2:1
 "sort"
//line delayed_test.go2:1
 "sync"
//line delayed_test.go2:1
 "testing"
//line delayed_test.go2:1
 "time"
//line delayed_test.go2:1
)

//line delayed_test.go2:15
const u = 20 * time.Millisecond

func TestAsCompletedDelayed(t *testing.T) {
	t.Parallel()
	var fs []*instantiate୦୦F୦struct୮4୮5
	s := time.Now()
	for i := range iter.N(10) {
		f := timeoutFuture(time.Duration(i) * u)
		f.SetName(fmt.Sprintf("%d", i))
		fs = append(fs, f)
	}
	as := instantiate୦୦AsCompletedDelayed୦struct୮4୮5(
		context.Background(),
		[]*instantiate୦୦F୦struct୮4୮5{fs[0], fs[2]},
		[]instantiate୦୦Delayed୦struct୮4୮5{
			{u, []*instantiate୦୦F୦struct୮4୮5{fs[1]}},
			{3 * u, []*instantiate୦୦F୦struct୮4୮5{fs[0]}},
		},
	)
	a := func(f, when time.Duration) {
		t.Helper()
		next := <-as
		if next != fs[f] {
			t.FailNow()
		}

		if time.Since(s) < when*u {
			t.Errorf("%d completed too soon", f)
		}
		if time.Since(s) >= (when+1)*u {
			t.Errorf("%d completed too late", f)
		}
	}
	a(0, 0)
	a(1, 1)
	a(2, 2)
	a(0, 2)
	_, ok := <-as
	if ok {
		t.FailNow()
	}
	if time.Since(s) >= 4*u {
		t.Fatal("took too long")
	}

//line delayed_test.go2:61
}

func TestAsCompletedDelayedContextCanceled(t *testing.T) {
	t.Parallel()
	var fs []*instantiate୦୦F୦struct୮4୮5
	s := time.Now()
	for i := range iter.N(10) {
		f := timeoutFuture(time.Duration(i) * u)
		f.SetName(fmt.Sprintf("%d", i))
		fs = append(fs, f)
	}
	ctx, cancel := context.WithCancel(context.Background())
	as := instantiate୦୦AsCompletedDelayed୦struct୮4୮5(
		ctx,
		[]*instantiate୦୦F୦struct୮4୮5{fs[0], fs[2]},
		[]instantiate୦୦Delayed୦struct୮4୮5{
			{u, []*instantiate୦୦F୦struct୮4୮5{fs[1]}},
			{3 * u, []*instantiate୦୦F୦struct୮4୮5{fs[0]}},
		},
	)
	a := func(f, when time.Duration) {
		t.Helper()
		next := <-as
		if next != fs[f] {
			t.Fatal("got wrong future")
		}

		if time.Since(s) < when*u {
			t.Errorf("%d completed too soon", f)
		}
		if time.Since(s) >= (when+1)*u {
			t.Errorf("%d completed too late", f)
		}
	}
	a(0, 0)
	cancel()
	_, ok := <-as
	if ok {
		t.FailNow()
	}
	if time.Since(s) >= u {
		t.Fatal("took too long")
	}

//line delayed_test.go2:106
}

func TestAsCompletedImmediate(t *testing.T) {
	t.Parallel()
	var fs []*instantiate୦୦F୦struct୮4୮5
	s := time.Now()
	for i := range iter.N(10) {
		f := timeoutFuture(0)
		f.SetName(fmt.Sprintf("%d", i))
		fs = append(fs, f)
	}
	as := instantiate୦୦AsCompletedDelayed୦struct୮4୮5(
		context.Background(),
		[]*instantiate୦୦F୦struct୮4୮5{fs[0], fs[2]},
		[]instantiate୦୦Delayed୦struct୮4୮5{
			{u, []*instantiate୦୦F୦struct୮4୮5{fs[1]}},
			{3 * u, []*instantiate୦୦F୦struct୮4୮5{fs[0]}},
		},
	)
	a := func(when time.Duration, indices ...int) {
		t.Helper()
		var got []int
		for len(got) != len(indices) {
			next := <-as
			for i, f := range fs {
				if next == f {
					got = append(got, i)
				}
			}
		}
		sort.Ints(got)
		for i := range indices {
			if indices[i] != got[i] {
				t.Fatalf("expected future %v, got %v", indices[i], got[i])
			}
		}
		if time.Since(s) < when*u {
			t.Errorf("completed too soon")
		}
		if time.Since(s) >= (when+1)*u {
			t.Errorf("completed too late")
		}
	}
	a(0, 0, 2)
	a(0, 1)
	a(0, 0)
	_, ok := <-as
	if ok {
		t.FailNow()
	}
	if time.Since(s) >= 4*u {
		t.Fatal("took too long")
	}

//line delayed_test.go2:161
}
//line funcs.go2:44
func instantiate୦୦AsCompletedDelayed୦struct୮4୮5(ctx context.Context, initial []*instantiate୦୦F୦struct୮4୮5, delayed []instantiate୦୦Delayed୦struct୮4୮5,) <-chan *instantiate୦୦F୦struct୮4୮5 {
	ret := make(chan *instantiate୦୦F୦struct୮4୮5, func() int {
		l := len(initial)
		for _, d := range delayed {
			l += len(d.Fs)
		}
		return l
	}())
	go func() {
		defer close(ret)
		var (
			dss      []instantiate୦୦delayedState୦int
			timeouts = map[*instantiate୦୦F୦int]struct{}{}
		)
		for i := range delayed {
			func(i int) {
				f := instantiate୦୦Start୦int(func() (int, error) {
					select {
					case <-time.After(delayed[i].Delay):
						return i, nil
					case <-ctx.Done():
						return -1, ctx.Err()
					}
				})
				timeouts[f] = struct{}{}
				dss = append(dss, instantiate୦୦delayedState୦int{timeout: f})
			}(i)
		}

		results := map[*instantiate୦୦F୦struct୮4୮5]int{}
		for _, f := range initial {
			results[f]++
		}
	start:

		resultsSlice := func() (ret []*instantiate୦୦F୦struct୮4୮5,) {
			for f, left := range results {
				for range iter.N(left) {
					ret = append(ret, f)
				}
			}
			return
		}()
		if len(resultsSlice) == 0 {
			for i, ds := range dss {
				if ds.added {
					continue
				}

				delete(timeouts, ds.timeout)
				for _, f := range delayed[i].Fs {
					results[f]++
				}
				dss[i].added = true

				goto start
			}
		}
		as := instantiate୦୦AsCompleted୦struct୮4୮5(resultsSlice...)
		timeoutsChan := instantiate୦୦AsCompleted୦int(slices.FromMapKeys(timeouts).([]*instantiate୦୦F୦int)...)
		for {
			select {
			case <-ctx.Done():
				return
			case f, ok := <-timeoutsChan:
				if !ok {
					timeoutsChan = nil
					break
				}
				if ctx.Err() != nil {
					break
				}
				i := f.MustResult()
				for _, f := range delayed[i].Fs {
					results[f]++
				}
				delete(timeouts, f)
				dss[i].added = true
				goto start
			case f, ok := <-as:
				if !ok {
					return
				}
				select {
				case ret <- f:
					results[f]--
					if results[f] == 0 {
						delete(results, f)
					}
					if len(results) == 0 {
						goto start
					}
				case <-ctx.Done():
					return
				}
			}
		}
	}()
	return ret
}

//line funcs.go2:143
type instantiate୦୦Delayed୦struct୮4୮5 struct {
//line delayed.go2:13
 Delay time.Duration
			Fs    []*instantiate୦୦F୦struct୮4୮5
}
//line delayed.go2:15
type instantiate୦୦delayedState୦int struct {
//line funcs.go2:35
 timeout *instantiate୦୦F୦int
	added bool
}
//line funcs.go2:37
type instantiate୦୦F୦int struct {
//line future.go2:25
 name   string
			mu     sync.Mutex
			result int
			err    error
			done   chan struct{}
}

func (f *instantiate୦୦F୦int,) String() string {
	if f.name != "" {
		return f.name
	}
	return fmt.Sprintf("future %p", f)
}

func (f *instantiate୦୦F୦int,) SetName(s string) {
	f.name = s
}

func (f *instantiate୦୦F୦int,) Err() error {
	<-f.done
	return f.err
}

//line future.go2:49
func (f *instantiate୦୦F୦int,) Result() (

//line funcs.go2:56
 int, error) {
//line future.go2:50
 <-f.done
			f.mu.Lock()
			defer f.mu.Unlock()
			return f.result, f.err
}

func (f *instantiate୦୦F୦int,) MustResult() int {
	val, err := f.Result()
	if err != nil {
		panic(err)
	}
	return val
}

func (f *instantiate୦୦F୦int,) Done() <-chan struct{} {
	return f.done
}

func (f *instantiate୦୦F୦int,) setResult(result int,

//line future.go2:68
 err error) {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.result = result
	f.err = err
	close(f.done)
}

func (f *instantiate୦୦F୦int,) ScanResult(res *int,

//line future.go2:76
) (err error) {
	*res, err = f.Result()
	return
}
//line future.go2:8
func instantiate୦୦Start୦int(fn func() (int, error)) *instantiate୦୦F୦int {
	f := &instantiate୦୦F୦int{
		done: make(chan struct{}),
	}
	go func() {
		f.setResult(fn())
	}()
	return f
}
//line funcs.go2:15
func instantiate୦୦AsCompleted୦struct୮4୮5(fs ...*instantiate୦୦F୦struct୮4୮5,) <-chan *instantiate୦୦F୦struct୮4୮5 {
	ret := make(chan *instantiate୦୦F୦struct୮4୮5, len(fs))
	var wg sync.WaitGroup
	for _, f := range fs {
		wg.Add(1)
		go func(f *instantiate୦୦F୦struct୮4୮5,) {
			defer wg.Done()
			<-f.Done()
			ret <- f
		}(f)
	}
	go func() {
		wg.Wait()
		close(ret)
	}()
	return ret
}
//line funcs.go2:15
func instantiate୦୦AsCompleted୦int(fs ...*instantiate୦୦F୦int,) <-chan *instantiate୦୦F୦int {
	ret := make(chan *instantiate୦୦F୦int, len(fs))
	var wg sync.WaitGroup
	for _, f := range fs {
		wg.Add(1)
		go func(f *instantiate୦୦F୦int,) {
			defer wg.Done()
			<-f.Done()
			ret <- f
		}(f)
	}
	go func() {
		wg.Wait()
		close(ret)
	}()
	return ret
}

//line funcs.go2:31
var _ = context.Background
//line funcs.go2:31
var _ = fmt.Errorf
//line funcs.go2:31
var _ = slices.FilterInPlace
//line funcs.go2:31
var _ = iter.N

//line funcs.go2:31
type _ sort.Float64Slice
//line funcs.go2:31
type _ sync.Cond

//line funcs.go2:31
var _ = testing.AllocsPerRun

//line funcs.go2:31
const _ = time.ANSIC
